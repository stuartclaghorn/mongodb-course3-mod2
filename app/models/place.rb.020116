class Place
  include ActiveModel::Model

  attr_accessor :id, :formatted_address, :location, :address_components

  Mongoid.logger.level = Logger::INFO

  # convenience method for access to client in console
  def self.mongo_client
    Mongoid::Clients.default
  end

  # convenience method for access to places collection
  def self.collection
    self.mongo_client['places']
  end

  # load json data into places collection
  def self.load_all(file_path)
    f=File.read(file_path)
    hash=JSON.parse(f)
    @coll=self.collection.insert_many(hash)
  end

  # initialize
  def initialize(params)
    Rails.logger.debug(params)
    @id=params[:_id].nil? ? params[:id] : params[:_id].to_s
    @address_components=[]
    params[:address_components].each do |c|
        @address_components << AddressComponent.new(c) if !params[:address_components].nil?
    end
    @formatted_address=params[:formatted_address]
    @location=Point.new(params[:geometry][:geolocation])
  end

  # queries
  def self.find_by_short_name(name)
    @coll=self.collection.find({'address_components.short_name' => name})
  end

  def self.to_places(coll)
    result=[]
    coll.map { |d| result << Place.new(d) }
    return result
  end

  def self.find(id)
    result=self.collection.find({:_id => BSON::ObjectId.from_string(id)}).first
    return result.nil? ? nil : Place.new(result)
  end

  def self.all(offset=0, limit=nil)
    Rails.logger.debug {"getting all places, offset=#{offset}, limit=#{limit}"}

    coll=collection.find().skip(offset)
    coll=coll.limit(limit) if !limit.nil?
    result=to_places(coll)
    return result
  end

  def destroy
    Rails.logger.debug {"destroying #{self}"}

    self.class.collection.find(:_id => BSON::ObjectId.from_string(@id)).delete_one
  end

  def self.get_address_components(sort={:_id=>1}, offset=0, limit=9999)
    pipeline=[{:$project=>{'_id'=>1,"address_components"=>1,"formatted_address"=>1,
               "geometry.geolocation"=>1}},
               {:$unwind=>"$address_components"},
               {:$sort=>sort},
               {:$skip=>offset}]
    if !limit.nil? 
      pipeline<<{:$limit=>limit}
    end
    result=self.collection.find.aggregate(pipeline)
    return result
  end
end
